# 事件环

这是一张 js 任务执行顺序图，从图中我们可以看到我们代码会根据特性进入不同的环境。

![](/任务队列.png)

## 1.同步任务和异步任务

### 1.同步任务

任务会进入执行栈中从上往下执行执行

```javascript
console.log(1);
new Promise(function(resolve, reject) {
  console.log(2);
});
```

> 模拟代码执行过程
- 1.主执行栈中执行同步代码,代码从上往下执行，依次打印 1，2
```javascript
console.log(1);
new Promise(function(resolve, reject) {
  console.log(2);
}); //1,2
```

### 2.异步任务

##### 2.1.当任务中有异步任务时，在执行栈中异步任务会进入 Event Table 并注册回调函数放到任务队列中。当主线程中的同步任务执行完后，会读取中的异步任务中的任务队列，放到主执行栈中执行。

```javascript
console.log(1);
setTimeout(function() {
  console.log(2);
}, 0);
setTimeout(function() {
  console.log(3);
}, 0);
```

> 模拟代码执行过程
- 1.主执行栈中执行同步代码，异步代码进入任务队列中,打印 1
  - 1.主执行栈
  ```javascript
  console.log(1);
  ```
  - 2.任务队列
  ```javascript
  setTimeout(function() {
    console.log(2);
  }, 0);
  setTimeout(function() {
    console.log(3);
  }, 0);
  ```
- 2.主执行栈中拿到任务队列中的代码执行，打印 2，3
  - 1.主执行栈
  ```javascript
  console.log(2);
  console.log(3);
  ```

- 像这样任务队列不断地取出放到主线程中执行，重复以上过程就是事件环（Event Loop）。

`宏任务和微任务`

- 上面我们说了，异步代码会进入任务队列，但是任务队列中又分为宏任务队列和微任务队列。

- 宏任务：
  - timers（计时器）执行 setTimeout 以及 setInterval 回调
  - poll（轮询）执行 poll 中的 i/o 队列检查定时器是否到时
  - check（检查）存放 setImmediate 回调
- 微任务：
  - process.nextTick
  - Promise

##### 2.2 代码放到任务队列里时，会区分是放到宏任务队列还是微任务队列，主线程任务执行完任务后会首先执行完微任务队列里的任务，然后清空微任务队列，再执行宏任务队列里的任务。

```javascript
setTimeout(function() {
  console.log(1);
}, 0);
process.nextTick(function() {
  console.log(2);
});
setTimeout(function() {
  console.log(3);
}, 0);
```

> 模拟代码执行的过程
- 1.主执行栈中没有代码执行，异步任务中宏任务进入宏任务队列，微任务进入微任务队列
  - 1.主执行栈
  ```javascript
  //
  ```
  - 2.任务队列
    - 1.微任务
    ```javascript
    process.nextTick(function() {
      console.log(2);
    });
    ```
    - 2.宏任务
    ```javascript
    setTimeout(function() {
      console.log(1);
    }, 0);
    setTimeout(function() {
      console.log(3);
    }, 0);
    ```
- 2.主执行栈中执行微任务，打印 2
  - 1.主执行栈
  ```javascript
  console.log(2);
  ```
  - 2.任务队列
    - 2.宏任务
      ```javascript
      setTimeout(function() {
        console.log(1);
      }, 0);
      setTimeout(function() {
        console.log(3);
      }, 0);
      ```
- 3.主执行栈中执行宏任务，打印 1，3
  - 1.主执行栈
  ```javascript
  console.log(1);
  console.log(3);
  ```

##### 2.3 当宏任务里面有微任务时，会先把宏任务队列执行完，切换宏任务类型之前先执行完微任务，清空微任务队列

如 timer 这个队列，执行宏任务没有切换宏任务类型：

```javascript
setTimeout(function() {
  console.log(1);
  process.nextTick(function() {
    console.log(2);
  });
}, 0);

setTimeout(function() {
  console.log(3);
  process.nextTick(function() {
    console.log(4);
  });
}, 0);
//1,3,2,4
```

> 模拟代码执行过程
- 1.主执行栈中没有代码执行，timer 进入宏任务队列
  - 1.主执行栈
  ```
  //
  ```
  - 2.任务队列
    - 2.宏任务队列
    ```javascript
    setTimeout(function() {
      console.log(1);
      process.nextTick(function() {
        console.log(2);
      });
    }, 0);
    setTimeout(function() {
      console.log(3);
      process.nextTick(function() {
        console.log(4);
      });
    }, 0);
    ```
- 2.主执行栈执行宏任务，微任务进入微任务队列，打印 1，3
  - 1.主执行栈
  ```javascript
  console.log(1);
  console.log(3);
  ```
  - 2.任务队列
    - 1.微任务队列
    ```javascript
    process.nextTick(function() {
      console.log(2);
    });
    process.nextTick(function() {
      console.log(4);
    });
    ```
- 3.主执行栈执行微任务,打印 2，4
  - 1.主执行栈
  ```javascript
  console.log(2);
  console.log(4);
  ```

##### 2.5 如 timer 和 poll 这个队列，执行宏任务有切换宏任务类型：

```javascript
let fs = require("fs");
fs.readFile("1.txt", function() {
  console.log(1);
  process.nextTick(function() {
    console.log(2);
  });
});
setTimeout(function() {
  console.log(3);
  process.nextTick(function() {
    console.log(4);
  });
}, 0);
```

> 模拟代码执行过程
- 1.主执行栈执行同步代码，异步代码进入宏任务队列中 timer 队列和 poll 队列
  - 1.主执行栈
  ```javascript
  let fs = require("fs");
  ```
  - 2.任务队列
    - 2.宏任务
      - 1.timer 队列
      ```javascript
      setTimeout(function() {
        console.log(3);
        process.nextTick(function() {
          console.log(4);
        });
      }, 0);
      ```
      - 2.poll 队列
      ```javascript
      fs.readFile("1.txt", function() {
        console.log(1);
        process.nextTick(function() {
          console.log(2);
        });
      });
      ```
- 2.主执行栈中执行任务队列里的任务，发现没有微任务，就执行宏任务，当有多种类型的宏任务时，就按 timers -- poll -- check 顺序执行，先执行 timer 队列里的任务,打印 3
  - 1.主执行栈
  ```javascript
  console.log(3);
  ```
  - 2.任务队列
    - 1.微任务
    ```javascript
    process.nextTick(function() {
      console.log(4);
    });
    ```
    - 2.宏任务
    ```javascript
    fs.readFile("1.txt", function() {
      console.log(1);
      process.nextTick(function() {
        console.log(2);
      });
    });
    ```
- 3.主执行栈执行微任务，打印 4
  - 1.主执行栈
  ```javascript
  console.log(4);
  ```
  - 2.任务队列
    - 2.宏任务
    ```javascript
    fs.readFile("1.txt", function() {
      console.log(1);
      process.nextTick(function() {
        console.log(2);
      });
    });
    ```
- 4.主执行栈中执行宏任务，打印 1，微任务进入微任务队列
  - 1.主执行栈
  ```javascript
  console.log(1);
  ```
  - 2.任务队列
    - 1.微任务队列
    ```javascript
    process.nextTick(function() {
      console.log(2);
    });
    ```
- 5.主执行栈中执行微任务,打印 2
  - 1.主执行栈
  ```javascript
  console.log(2);
  ```

##### 2.6 当宏任务为不同的类型时，宏任务执行顺序为 timers -- poll -- check，但是还是会看谁先执行完

- 如 timers 在 check 前面：

```javascript
setTimeout(function() {
  console.log(1);
}, 1000);
setImmediate(function() {
  console.log(2);
});
```

//因为 check 执行的时间更短

> 模拟代码执行的过程
- 1.主执行栈中无同步代码执行，异步任务中宏任务 timers 进入 timers 队列，check 进入 check 队列
  - 1.主执行栈
  ```
  //
  ```
  - 2.任务队列
    - 2.宏任务
      - 1.timers 队列
      ```javascript
      setTimeout(function() {
        console.log(1);
      }, 1000);
      ```
      - 3.check 队列
      ```javascript
      setImmediate(function() {
        console.log(2);
      });
      ```
- 2.主执行栈中执行宏任务，由于 check 时间更短，先执行 check 任务，打印 2
  - 1.主执行栈
  ```javascript
  console.log(2);
  ```
  - 2.任务队列
    - 2.宏任务队列
    ```javascript
    setTimeout(function() {
      console.log(1);
    }, 1000);
    ```
- 3.主执行栈中执行宏任务，打印 1
  - 1.主执行栈
  ```javascript
  console.log(1);
  ```

- 如 timers 在 check 前面，但是 timers 执行的时间不确定：

```javascript
setTimeout(function() {
  console.log(1);
}, 0);
setImmediate(function() {
  console.log(2);
});
//2,1 或者 1,2
```

> 模拟代码执行的顺序
- 1.主执行栈中没有代码执行，异步任务中宏任务进入 timers 和 check 任务队列
  - 1.主执行栈
  ```javascript
  //
  ```
  - 2.任务队列
    - 2.宏任务
      - 1.timers 队列
      ```javascript
      setTimeout(function() {
        console.log(1);
      }, 0);
      ```
      - 3.check 队列
      ```javascript
      setImmediate(function() {
        console.log(2);
      });
      ```
- 2.主执行栈中执行宏任务，由于不知道 timers 和 check 谁先执行完，所有有两种结果(这里取 timers 先执行完)，打印 1
  - 1.主执行栈
  ```javascript
  console.log(1);
  ```
  - 2.任务队列
    - 2.宏任务
    ```javascript
    setImmediate(function() {
      console.log(2);
    });
    ```
- 3.主执行栈中执行宏任务,打印 2
  - 1.主执行栈
  ```javascript
  console.log(2);
  ```

##### 2.7 宏任务里面有宏任务时，里面的宏任务会在当前的宏任务下面比较

如 poll 中嵌套 timers 和 check，代码执行完 poll 后会先走 poll 顺序下的 check，然后才执行 timers 而不是上面那样谁的时间短执行谁：

```javascript
let fs = require("fs")
fs.readFile("1.txt", function () {
    setTimeout(function () {
        console.log(1);
    }, 0);
    setImmediate(function () {
        console.log(2)
    })
})
//2,1
```

> 模拟代码执行
- 1.主执行栈中执行同步代码，异步代码中宏任务进入poll任务队列
    - 1.主执行栈
    ```javascript
    let fs = require("fs")
    ```
    - 2.任务队列
        - 2.宏任务
            - 2.poll任务队列
            ```javascript
            fs.readFile("1.txt", function () {
                setTimeout(function () {
                    console.log(1);
                }, 0);
                setImmediate(function () {
                    console.log(2)
                })
            })
            ```
- 2.主执行栈中执行宏任务中的poll任务队列代码,里面的宏任务各自进入timers和check任务队列
    - 1.主执行栈
    ```javascript
    fs.readFile("1.txt", function () {
        ...
    })
    ```
    - 2.任务队列
        - 1.timers任务队列
        ```javascript
        setTimeout(function () {
            console.log(1);
        }, 0);
        ```
        - 3.check任务队列
        ```javascript
        setImmediate(function () {
            console.log(2)
        })
        ```
- 3.主执行栈中由于之前执行的是poll宏任务,打印2，如果接下来执行宏任务,宏任务为check，那么会优先执行check
    - 1.主执行栈
    ```javascript
        console.log(2)
    ```
    - 2.任务队列
        - 2.宏任务
        ```javascript
        setTimeout(function () {
            console.log(1);
        }, 0);
        ```
- 4.主执行栈中执行宏任务，打印1
    - 1.主执行栈
    ```javascript
    console.log(1);
    ```
    
##### 2.8微任务中由于 process.nextTick 比 promise 中的 then 快所以同一个微任务队列中 process.nextTick 先执行

```javascript
new Promise(function (resolve, reject) {
    resolve()
}).then(function () {
    console.log(2);
})
process.nextTick(function () {
    console.log(1);
})
//1,2
```

> 模拟代码执行过程
- 1.主执行栈中执行 promise 同步方法，异步代码进入微任务队列
  - 1.主执行栈
  ```javascript
  new Promise(function (resolve, reject) {
  resolve()
  })
  ```
  - 2.任务队列
    - 1.微任务
      - 1.nextTick 队列
      ```javascript
      then(function () {
          console.log(2);
      })
      ```
      - 2.promise 队列
      ```javascript
      process.nextTick(function () {
          console.log(1);
      })
      ```
- 2.主执行栈中执行 nextTick 队列-->1
  - 1.主执行栈
  ```javascript
  console.log(1);
  ```
  - 2.任务队列
  - 1.微任务队列
    ```javascript
    then(function () {
        console.log(2);
    })
    ```
- 3.主执行栈中执行 then
  - 1.主执行栈
  ```javascript
  console.log(2);
  ```

##### 2.8 微任务中有宏任务时，微任务宏任务执行顺序和上面的一样

- 如下宏任务在微任务前执行是因为微任务执行的条件是宏任务类型切换时触发，下面的宏任务都是相同类型的所以没有触发微任务
```javascript
setTimeout(function () {
    console.log(1);
    process.nextTick(function () {
        console.log(2);
    });
}, 0);
process.nextTick(function () {
    console.log(3);
    setTimeout(function () {
        console.log(4);
    }, 0);
}) //3,1,4,2
```

> 模拟代码执行的顺序
- 1.主执行栈中没有同步代码，异步队列中分配宏任务和微任务
    - 1.主执行栈
    ```javascript
    //
    ```
    - 2.任务队列
        - 1.微任务
        ```javascript
        process.nextTick(function () {
            console.log(3);
            setTimeout(function () {
                console.log(4);
            }, 0);
        })
        ```
        - 2.宏任务
        ```javascript
        setTimeout(function () {
            console.log(1);
            process.nextTick(function () {
                console.log(2);
            });
        }, 0);
        ```
- 2.主执行栈中将拿到微任务队列代码执行，微任务中的宏任务进入宏任务队列-->3
    - 1.主执行栈
    ```javascript
    console.log(3);
    ```
    - 2.任务队列
        - 2.宏任务队列（timer类型）
        ```javascript
        setTimeout(function () {
            console.log(1);
            process.nextTick(function () {
                console.log(2);
            });
        }, 0);
        setTimeout(function () {
            console.log(4);
        }, 0);
        ```
- 3.宏任务队列中代码在主执行栈中执行，其中微任务进入微任务队列-->1，4
    - 1.主执行栈
    ```javascript
    console.log(1);
    console.log(4);
    ```
    - 2.任务队列
        - 1.微任务
        ```javascript
        process.nextTick(function () {
            console.log(2);
        });
        ```
- 4.执行微任务-->2
    - 1.主执行栈
    ```javascript
    console.log(2);
    ```

#### 最后总结一下：

宏任务：timers -- poll -- check 这个任务执行顺序和这个任务执行的时间综合考虑

微任务：process.nextTick --promise

执行微任务的条件是宏任务类型切换时，或者主线程中同步任务执行完微任务队列还有微任务时

